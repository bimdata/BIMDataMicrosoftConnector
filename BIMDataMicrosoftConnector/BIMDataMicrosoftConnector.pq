// This file contains your Data Connector logic
section BIMDataMicrosoftConnector;

client_id = "710475";
client_secret = "1d2418b086b670cbbf5516b8af98121476abfe983cd1e167e8364669";
redirect_uri = "http://www.lewifi.fr/";
token_uri = "https://login-staging.bimdata.io/token";
authorize_uri = "https://login-staging.bimdata.io/authorize";

scope_prefix = "";
scopes = "bcf:read bcf:write check:read check:write webhook:manage ifc:read ifc:write cloud:read cloud:manage org:manage document:read document:write user:read openid profile email";

[DataSource.Kind="BIMDataMicrosoftConnector", Publish="BIMDataMicrosoftConnector.Publish"]
shared BIMDataMicrosoftConnector.RefreshToken = () =>
    let
        result = Json.Document(Web.Contents("https://api-staging.bimdata.io/cloud"))
    in
        result; 

[DataSource.Kind="BIMDataMicrosoftConnector", Publish="BIMDataMicrosoftConnector.Publish"]
shared BIMDataMicrosoftConnector.GetToken = () =>
    let
        access_token = Extension.CurrentCredential()[access_token]
    in
        access_token; 

// Data Source Kind description
BIMDataMicrosoftConnector = [
    TestConnection = (dataSourcePath) => { "BIMDataMicrosoftConnector.Contents", dataSourcePath },
    Authentication = [
    Implicit = [],
        OAuth = [
            StartLogin=StartLogin,
            FinishLogin=FinishLogin
        ]
    ],
    Label = Extension.LoadString("DataSourceLabel")
];

// Data Source UI publishing description
BIMDataMicrosoftConnector.Publish = [
    Beta = true,
    Category = "Other",
    ButtonText = { Extension.LoadString("ButtonTitle"), Extension.LoadString("ButtonHelp") },
    LearnMoreUrl = "https://powerbi.microsoft.com/",
    SourceImage = BIMDataMicrosoftConnector.Icons,
    SourceTypeImage = BIMDataMicrosoftConnector.Icons
];

BIMDataMicrosoftConnector.Icons = [
    Icon16 = { Extension.Contents("BIMDataMicrosoftConnector16.png"), Extension.Contents("BIMDataMicrosoftConnector20.png"), Extension.Contents("BIMDataMicrosoftConnector24.png"), Extension.Contents("BIMDataMicrosoftConnector32.png") },
    Icon32 = { Extension.Contents("BIMDataMicrosoftConnector32.png"), Extension.Contents("BIMDataMicrosoftConnector40.png"), Extension.Contents("BIMDataMicrosoftConnector48.png"), Extension.Contents("BIMDataMicrosoftConnector64.png") }
];

StartLogin = (resourceUrl, state, display) =>
    let
        authorizeUrl = authorize_uri & "?" & Uri.BuildQueryString([
            response_type = "id_token token",
            client_id = client_id,
            client_secret = client_secret,
            redirect_uri = redirect_uri,
            state = state,
            scope = scopes,
            nonce = GenerateRandomString()
        ])
    in
        [
            LoginUri = authorizeUrl,
            CallbackUri = redirect_uri,
            WindowHeight = 720,
            WindowWidth = 1024,
            Context = null
        ];

FinishLogin = (context, callbackUri, state) =>
    let
        // parse the full callbackUri, and extract the Query string
        fragment = Uri.Parts(callbackUri)[Fragment],
        //fragmentList = Text.Split(fragment, "access_token="),
        fragments = Text.Split(fragment, "&"),
        parts = List.Accumulate(fragments, [], (state, current) => Record.AddField(state, Text.Split(current, "="){0}, Text.Split(current, "="){1})),
        table = Table.FromRecords([parts]),
        // if the query string contains an "error" field, raise an error
        // otherwise call TokenMethod to exchange our code for an access_token
        result = if (Record.HasFields(parts, {"error", "error_description"})) then
                    error Error.Record(parts[error], parts[error_description], parts)
                 else
                    parts
    in
        result;

Value.IfNull = (a, b) => if a <> null then a else b;
       
GenerateRandomString = () =>
    let 
    StringLength = 32,
    ValidCharacters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456879",
    fnRandomCharacter = (text) => Text.Range(ValidCharacters,Int32.From(Number.RandomBetween(0, Text.Length(ValidCharacters)-1)),1),
    GenerateList = List.Generate(()=> [Counter=0, Character=fnRandomCharacter(ValidCharacters)],
                   each [Counter] < StringLength,
                   each [Counter=[Counter]+1, Character=fnRandomCharacter(ValidCharacters)],
                   each [Character]),
    RandomString = List.Accumulate(GenerateList, "", (a,b) => a & b)
    in
        RandomString;